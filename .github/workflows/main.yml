name: Code Quality Scans
run-name: Code Quality Scans

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION_FILE: '.nvmrc'

jobs:
  scan:
    name: Run Code Quality Scans
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js version in .nvmrc
        uses: actions/setup-node@v3
        with:
          node-version-file: ${{ env.NODE_VERSION_FILE }}
          cache: 'npm'
      - name: Node Cache
        id: node-cache
        uses: actions/cache@v3
        env:
          cache-name: node-cache
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ github.repository }}-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ github.repository }}-${{ env.cache-name }}-
            ${{ github.repository }}-
      - name: Install Dependencies
        run: npm ci --ignore-scripts
      - name: Run Test on Distribution ID
        id: distribution-id
        script:
          const { ref } = context;
          console.log('ref:', ref);

          const refArray = ref.split('/');
          console.log('refArray:', refArray);

          const branch = refArray[refArray.length - 1];
          console.log('branch:', branch);

          const branchLabel = branch === 'main' ? 'Prod' : branch[0].toUpperCase() + branch.slice(1);
          console.log('branchLabel:', branchLabel);

          const stackName = `RecipesBranchStack${ branchLabel }`
          console.log('stackName:', stackName);

          const distributionLabel = `ExportRecipesDistribution${ branchSlug }`
          console.log('distributionLabel:', distributionLabel);

          const cloudformation = new CloudFormation({ apiVersion: API_VERSION, region });
          const exportsList = {};
          
          const result = await cloudformation
            .describeStacks({ StackName: stackName })
            .promise();
            
          const foundStacks = (result && result.Stacks) || [];
          
          const stack = foundStacks.find(s => s.StackName === stackName);
          if (!stack) {
            throw new Error(`Unable to find stack "${stackName}" in region "${region}"`);
          }

          stack.Outputs.forEach(({ OutputKey, ExportName, OutputValue }) => {
            exportsList[byOutputKey ? OutputKey : ExportName] = OutputValue;
          });
          
          console.log(exportsList);
          
          return exportsList;
